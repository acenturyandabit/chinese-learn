import getAiJsonResponse from "./get-ai-json-response";

type SentenceResponse = { sentence: string, pinyin: string, definition: string };

const TAIL_MARKER = null;
const cache: Record<string, Record<string, SentenceResponse | typeof TAIL_MARKER>> = {};

export const addMakeSentence = (app: any) => {
  // Return a sentence generated by AI. To prevent overuse of the AI, we cache all responses
  // in a linked list, and only query the AI to extend the linked list. Each request returns 
  // a node in the linked list; the user can paginate through the linked list to get a new
  // sentence by providing the previousRequest.
  app.post("/make-sentence", async (req, res) => {
    // Check for a valid previousRequest before generating a new request. This helps ensure that users
    // do not spam this endpoint, and allows the frontend to paginate through cached sentences.
    const { key, previousRequest } = req.body as { key: string, previousRequest?: string };
    if (!cache[key]) {
      cache[key] = { [key]: TAIL_MARKER };
    }
    if (previousRequest && cache[key] && cache[key][previousRequest] === undefined) {
    }
    let definitePaginationKey = previousRequest ? previousRequest : key;
    if (cache[key][definitePaginationKey] == undefined) {
      // user tried to give an invalid previousRequest, or the client is out of sync 
      // with the server (maybe after a restart)
      // ignore previousRequest and just send the initial response
      definitePaginationKey = key;
    }
    if (cache[key][definitePaginationKey] === TAIL_MARKER) {
      // we have reached the end of the linked list
      // Use LLM to generate a new sentence
      const { result, error } = await generateSentence(key);
      if (error) {
        res.status(500).send(error);
        return;
      }
      cache[key][definitePaginationKey] = result;
    }
    res.send(cache[key][definitePaginationKey]);
  });
}

const generateSentence = async (key: string): Promise<{ result: SentenceResponse | null, error: string | null }> => {
  const promptWords = [...randomlySample(PROMPT_NOUNS, 3), ...randomlySample(PROMPT_VERBS, 3)].join(", ");
  return await getAiJsonResponse([
    { role: "system", content:
      `For the following chinese word, create a simple sentence. Here are some ideas of words you might want to use: ${promptWords} Return your answer in the following format: {\"sentence\": "把字写在这", "pinyin": "bǎi zì xiě zhè", "definition": "write the word here"}`
    },
    { role: "user", content: key },
  ]);
}

const randomlySample = (arr: string[], n: number) => {
  const shuffled = arr.sort(() => Math.random() - 0.5);
  return shuffled.slice(0, n);
};

const PROMPT_NOUNS = [
  "人", "家", "书", "车", "猫", "狗", "学校", "医生", "桌子", "椅子",
  "电话", "食物", "水", "天空", "星星", "电视", "电影", "音乐", "电脑", "手机",
  "朋友", "老师", "孩子", "父母", "老师", "医院", "公园", "商店", "公司", "大楼",
  "厨房", "餐厅", "市场", "城市", "乡村", "街道", "商场", "花园", "花", "树",
  "草", "海洋", "山", "河流", "岛屿", "冰箱", "衣服", "鞋子", "帽子", "眼镜",
  "报纸", "杂志", "地图", "信", "信封", "包", "钱包", "表", "照片", "画",
  "艺术", "球", "杯子", "刀", "叉", "勺子", "盘子", "碗", "牙刷", "牙膏",
  "毛巾", "浴缸", "浴室", "洗衣机", "床", "被子", "枕头", "电视机", "空调", "风扇",
  "电梯", "楼梯", "门", "窗户", "钥匙", "锁", "地板", "墙", "天花板", "屋顶",
  "时间", "日历", "年份", "月份", "星期", "时钟", "天气", "温度", "气候", "季节",
  "世界", "国家", "城市", "村庄", "语言", "文化", "历史", "科技", "教育", "政治"
];

const PROMPT_VERBS = [
  "做", "吃", "喝", "走", "跑", "跳", "看", "听", "说", "写",
  "读", "学习", "教", "睡", "工作", "玩", "看见", "听到", "感到", "认为",
  "爱", "喜欢", "帮助", "问", "回答", "打", "给", "拿", "放", "想",
  "记得", "忘记", "拿到", "放下", "买", "卖", "租", "住", "离开", "回",
  "去", "来", "看待", "找", "找到", "失去", "修理", "建立", "改变", "加入",
  "走到", "停", "开始", "结束", "等", "试", "喜欢", "安排", "担心", "期待",
  "听", "吃饭", "喝水", "生气", "高兴", "害怕", "笑", "哭", "问问题", "解释",
  "上", "下", "进", "出", "上班", "下班", "整理", "出现", "消失", "出现",
  "平静", "熄灭", "打开", "关上", "放弃", "完成", "参与", "忍受", "奖励", "挑战",
  "使用", "发现", "接受", "拒绝", "控制", "创造", "指导", "记住", "忘记", "成长",
  "改进", "准备", "忍耐", "拖延", "破坏", "保护", "展示", "吸引", "感受", "考虑"
];